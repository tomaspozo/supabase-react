---
description: Rules when writing SQL code and SQL files
alwaysApply: false
---
# Postgres SQL Style Guide

## General

- Use lowercase for SQL reserved words to maintain consistency and readability.
- Employ consistent, descriptive identifiers for tables, columns, and other database objects.
- Use white space and indentation to enhance the readability of your code.
- Store dates in ISO 8601 format (`yyyy-mm-ddThh:mm:ss.sssss`).
- Include comments for complex logic, using '/* ... */' for block comments and '--' for line comments.

## Naming Conventions

- Avoid SQL reserved words and ensure names are unique and under 63 characters.
- Use snake_case for tables and columns.
- Prefer plurals for table names
- Prefer singular names for columns.

## Tables

- Avoid prefixes like 'tbl_' and ensure no table name matches any of its column names.
- Always add an `id` column as the **primary key** unless otherwise specified.
- Create all tables in the `public` schema unless otherwise specified.
- Always add the schema to SQL queries for clarity.
- Always add a comment to describe what the table does. The comment can be up to 1024 characters.

### Primary Key Strategies

#### UUID Primary Keys (Recommended for most cases)

Use UUIDs when:
- Building distributed systems (multiple databases/regions)
- Need globally unique identifiers
- Security through obscurity (non-sequential IDs)
- Planning to merge data from multiple sources

```sql
create table public.contacts (
  id uuid default gen_random_uuid() primary key,
  name text not null,
  email text,
  created_at timestamp with time zone default now()
);
comment on table public.contacts is 'User contact information.';
```

**Benefits:**
- Globally unique across systems
- Better for distributed architectures
- Non-sequential (better security)
- No collision risk when merging data

#### Bigint Auto-Increment Primary Keys

Use bigint when:
- High performance is critical (slightly faster than UUID)
- Sequential IDs are acceptable
- Single database instance
- Analytics/queries benefit from sequential IDs

```sql
create table public.books (
  id bigint generated always as identity primary key,
  title text not null,
  author_id bigint references public.authors(id),
  created_at timestamp with time zone default now()
);
comment on table public.books is 'A list of all the books in the library.';
```

**Benefits:**
- Slightly faster (smaller index size)
- Sequential IDs (better for analytics)
- Simpler for joins and foreign keys
- Lower storage overhead

#### Generated Always vs Generated By Default

**`generated always`** (Recommended):
- Prevents manual ID insertion
- Guarantees sequence integrity
- Better for production systems

```sql
create table public.books (
  id bigint generated always as identity primary key,
  title text not null
);
-- This will fail:
insert into public.books (id, title) values (999, 'Manual ID');
```

**`generated by default`**:
- Allows manual ID insertion (use with caution)
- Useful for data migrations
- Can break sequence integrity

```sql
create table public.books (
  id bigint generated by default as identity primary key,
  title text not null
);
-- This will work:
insert into public.books (id, title) values (999, 'Manual ID');
```

**Recommendation:** Use `generated always` unless you have a specific need for manual ID insertion.

#### Composite Primary Keys

Use composite keys when:
- Natural business key exists (e.g., user_id + product_id)
- Need to enforce uniqueness across multiple columns
- Performance benefits from multi-column indexes

```sql
create table public.order_items (
  order_id uuid references public.orders(id) on delete cascade,
  product_id uuid references public.products(id) on delete restrict,
  quantity integer not null default 1,
  price numeric(10, 2) not null,
  primary key (order_id, product_id)
);
comment on table public.order_items is 'Items within an order. Each order-product combination is unique.';
```

**When NOT to use composite keys:**
- If you need a simple foreign key reference
- When the composite key is complex (more than 2-3 columns)
- If you're unsure about the natural key stability

## Columns

- Use singular names and avoid generic names like 'id'.
- For references to foreign tables, use the singular of the table name with the `_id` suffix. For example `user_id` to reference the `users` table
- Always use lowercase except in cases involving acronyms or when readability would be enhanced by an exception.

#### Examples:

**Example 1: UUID Primary Key**
```sql
create table public.contacts (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users(id) on delete cascade not null,
  name text not null,
  email text,
  phone text,
  created_at timestamp with time zone default now()
);
comment on table public.contacts is 'User contact information with UUID primary key.';
```

**Example 2: Bigint Auto-Increment Primary Key**
```sql
create table public.books (
  id bigint generated always as identity primary key,
  title text not null,
  author_id bigint references public.authors(id) on delete restrict
);
comment on table public.books is 'A list of all the books in the library with auto-increment ID.';
```

**Example 3: Composite Primary Key**
```sql
create table public.order_items (
  order_id uuid references public.orders(id) on delete cascade,
  product_id uuid references public.products(id) on delete restrict,
  quantity integer not null default 1,
  price numeric(10, 2) not null,
  primary key (order_id, product_id)
);
comment on table public.order_items is 'Items within an order. Each order-product combination is unique.';
```

## Primary Key Decision Guide

### When to Use UUID

✅ **Use UUID when:**
- Building distributed/multi-region systems
- Need globally unique identifiers
- Security through obscurity (non-sequential IDs)
- Planning to merge data from multiple databases
- Frontend generates IDs before insert
- Using Supabase Realtime (works well with UUIDs)

### When to Use Bigint

✅ **Use bigint when:**
- Single database instance
- High performance is critical (slightly faster)
- Sequential IDs are acceptable/desired
- Analytics benefit from sequential ordering
- Simpler joins and foreign keys preferred

### When to Use Composite Keys

✅ **Use composite keys when:**
- Natural business key exists (e.g., user_id + product_id)
- Need to enforce uniqueness across multiple columns
- Multi-column index provides performance benefits
- The composite key is stable and meaningful

### Best Practices

- **Default to UUID** for most Supabase applications (better for distributed systems)
- **Use `generated always`** for bigint identity columns (better integrity)
- **Use `default gen_random_uuid()`** for UUID columns (no sequence needed)
- **Avoid composite keys** unless you have a clear business requirement
- **Always add indexes** on foreign key columns for performance

## Types

PostgreSQL does not support `CREATE TYPE IF NOT EXISTS`. Use DO blocks with existence checks:

```sql
do $$
begin
  if not exists (select 1 from pg_type where typname = 'contact_type' and typnamespace = (select oid from pg_namespace where nspname = 'public')) then
    create type public.contact_type as enum ('person', 'company');
  end if;
end $$;
```

## Constraints

### Constraint Naming Best Practices

**Always name constraints explicitly** in CREATE TABLE statements to match existing database constraints:

```sql
-- Good: Explicitly named constraint
constraint contact_data_contact_field_unique unique (contact_id, field_definition_id)

-- Avoid: Auto-generated name may differ from database
unique (contact_id, field_definition_id)
```

This prevents migration diffs from attempting to drop/recreate constraints with different names.

## Queries

- When the query is shorter keep it on just a few lines. As it gets larger start adding newlines for readability
- Add spaces for readability.

Smaller queries:


```sql
select *
from employees
where end_date is null;

update employees
set end_date = '2023-12-31'
where employee_id = 1001;
```

Larger queries:

```sql
select
  first_name,
  last_name
from
  employees
where
  start_date between '2021-01-01' and '2021-12-31'
and
  status = 'employed';
```


### Joins and Subqueries

- Format joins and subqueries for clarity, aligning them with related SQL clauses.
- Prefer full table names when referencing tables. This helps for readability.

```sql
select
  employees.employee_name,
  departments.department_name
from
  employees
join
  departments on employees.department_id = departments.department_id
where
  employees.start_date > '2022-01-01';
```

## Aliases

- Use meaningful aliases that reflect the data or transformation applied, and always include the 'as' keyword for clarity.

```sql
select count(*) as total_employees
from employees
where end_date is null;
```


## Complex queries and CTEs

- If a query is extremely complex, prefer a CTE.
- Make sure the CTE is clear and linear. Prefer readability over performance.
- Add comments to each block.

```sql
with department_employees as (
  -- Get all employees and their departments
  select
    employees.department_id,
    employees.first_name,
    employees.last_name,
    departments.department_name
  from
    employees
  join
    departments on employees.department_id = departments.department_id
),
employee_counts as (
  -- Count how many employees in each department
  select
    department_name,
    count(*) as num_employees
  from
    department_employees
  group by
    department_name
)
select
  department_name,
  num_employees
from
  employee_counts
order by
  department_name;
```